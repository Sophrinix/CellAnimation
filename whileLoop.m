function output_args=whileLoop(function_struct)
%Usage
%This module is used to loop through a series of modules. The modules that will be looped
%through are listed in the LoopFunctions input structure member.
%
%Input Structure Members
%TestFunction – This structure details the function that will be used to determine when to exit the
%while loop. When the TestResult variable is set to false by TestFunction the loop exits.
%TestResult – The name of the variable in the output structure of TestFunction that determines
%when the while loop exits. This needs to be a boolean variable or convertible to one.
%Any other arguments may be added to the FunctionArgs structure and they will be available to
%the modules contained in the LoopFunctions structure member. This allows the loop modules to
%have access to values generated by modules outside the loop.
%
%Output Structure Members
%Any values generated by the modules in the loop can be made available to modules outside the
%loop by adding them to the KeepValues structure.
%
%Example
%
%assign_cells_to_tracks_loop.InstanceName='AssignCellsToTracksLoop';
%assign_cells_to_tracks_loop.FunctionHandle=@whileLoop;
%assign_cells_to_tracks_loop.TestFunction.InstanceName='IsNotEmptyUnassignedCe
%lls';
%assign_cells_to_tracks_loop.TestFunction.FunctionHandle=@isNotEmptyFunction;
%assign_cells_to_tracks_loop.TestFunction.FunctionArgs.TestVariable.FunctionIn
%stance='AssignCellsToTracksLoop';
%assign_cells_to_tracks_loop.TestFunction.FunctionArgs.TestVariable.InputArg='
%UnassignedCells';
%assign_cells_to_tracks_loop.FunctionArgs.TestResult.FunctionInstance='IsNotEm
%ptyUnassignedCells';
%assign_cells_to_tracks_loop.FunctionArgs.TestResult.OutputArg='Boolean';
%assign_cells_to_tracks_loop.FunctionArgs.UnassignedCells.FunctionInstance='Ma
%keUnassignedCellsList';
%assign_cells_to_tracks_loop.FunctionArgs.UnassignedCells.OutputArg='Unassigne
%dCellsIDs';
%assign_cells_to_tracks_loop.FunctionArgs.UnassignedCells.FunctionInstance2='A
%ssignCellToTrackUsingAll';
%assign_cells_to_tracks_loop.FunctionArgs.UnassignedCells.OutputArg2='Unassign
%edIDs';
%assign_cells_to_tracks_loop.FunctionArgs.ExcludedTracks.FunctionInstance='Mak
%eExcludedTracksList';
%assign_cells_to_tracks_loop.FunctionArgs.ExcludedTracks.OutputArg='ExcludedTr
%acks';
%
%assign_cells_to_tracks_loop.FunctionArgs.ExcludedTracks.FunctionInstance2='As
%signCellToTrackUsingAll';
%assign_cells_to_tracks_loop.FunctionArgs.ExcludedTracks.OutputArg2='ExcludedT
%racks';
%assign_cells_to_tracks_loop.FunctionArgs.CellsLabel.FunctionInstance='IfIsEmp
%tyPreviousCellsLabel';
%assign_cells_to_tracks_loop.FunctionArgs.CellsLabel.InputArg='CellsLabel';
%assign_cells_to_tracks_loop.FunctionArgs.PreviousCellsLabel.FunctionInstance=
%'IfIsEmptyPreviousCellsLabel';
%assign_cells_to_tracks_loop.FunctionArgs.PreviousCellsLabel.InputArg='Previou
%sCellsLabel';
%assign_cells_to_tracks_loop.FunctionArgs.ShapeParameters.FunctionInstance='Ge
%tShapeParameters';
%assign_cells_to_tracks_loop.FunctionArgs.ShapeParameters.OutputArg='ShapePara
%meters';
%assign_cells_to_tracks_loop.FunctionArgs.ShapeParameters.FunctionInstance2='S
%etMatchingGroupIndex';
%assign_cells_to_tracks_loop.FunctionArgs.ShapeParameters.OutputArg2='ShapePar
%ameters';
%assign_cells_to_tracks_loop.FunctionArgs.CellsCentroids.FunctionInstance='Get
%ShapeParameters';
%assign_cells_to_tracks_loop.FunctionArgs.CellsCentroids.OutputArg='Centroids'
%;
%assign_cells_to_tracks_loop.FunctionArgs.CurrentTracks.FunctionInstance='GetC
%urrentTracks';
%assign_cells_to_tracks_loop.FunctionArgs.CurrentTracks.OutputArg='Tracks';
%assign_cells_to_tracks_loop.FunctionArgs.TrackAssignments.FunctionInstance='I
%fIsEmptyPreviousCellsLabel';
%assign_cells_to_tracks_loop.FunctionArgs.TrackAssignments.InputArg='TrackAssi
%gnments';
%assign_cells_to_tracks_loop.FunctionArgs.TrackAssignments.FunctionInstance2='
%AssignCellToTrackUsingAll';
%assign_cells_to_tracks_loop.FunctionArgs.TrackAssignments.OutputArg2='TrackAs
%signments';
%assign_cells_to_tracks_loop.FunctionArgs.MaxTrackID.FunctionInstance='GetMaxT
%rackID';
%assign_cells_to_tracks_loop.FunctionArgs.MaxTrackID.OutputArg='MaxTrackID';
%assign_cells_to_tracks_loop.FunctionArgs.Tracks.FunctionInstance='IfIsEmptyPr
%eviousCellsLabel';
%assign_cells_to_tracks_loop.FunctionArgs.Tracks.InputArg='Tracks';
%assign_cells_to_tracks_loop.FunctionArgs.PreviousTracks.FunctionInstance='Get
%PreviousTracks';
%assign_cells_to_tracks_loop.FunctionArgs.PreviousTracks.OutputArg='Tracks';
%assign_cells_to_tracks_loop.KeepValues.TrackAssignments.FunctionInstance='Ass
%ignCellToTrackUsingAll';
%assign_cells_to_tracks_loop.KeepValues.TrackAssignments.OutputArg='TrackAssig
%nments';
%assign_cells_to_tracks_loop.KeepValues.ShapeParameters.FunctionInstance='SetM
%atchingGroupIndex';
%assign_cells_to_tracks_loop.KeepValues.ShapeParameters.OutputArg='ShapeParame
%ters';
%assign_cells_to_tracks_loop.KeepValues.MatchingGroups.FunctionInstance='Assig
%nCellToTrackUsingAll';
%assign_cells_to_tracks_loop.KeepValues.MatchingGroups.OutputArg='MatchingGrou
%ps';

global dependencies_list;
global dependencies_index;

instance_name=function_struct.InstanceName;
cur_idx=dependencies_index.get(instance_name);

%propagate any input args needed by the loop functions from outside
updateArgs(instance_name,function_struct.FunctionArgs,'input');
input_args=function_struct.FunctionArgs;
loop_functions=function_struct.LoopFunctions;

test_function_instance=function_struct.TestFunction.InstanceName;
test_function_handle=function_struct.TestFunction.FunctionHandle;
test_function_dependecy_idx=dependencies_index.get(test_function_instance);
test_function_dependency_item=dependencies_list{test_function_dependecy_idx};
test_output_name=input_args.TestResult.OutputArg;
test_output=test_function_handle(test_function_dependency_item.FunctionArgs);

while(test_output.(test_output_name))
    for j=1:size(loop_functions,1)
        loop_function_instance_name=loop_functions{j}.InstanceName;
        callFunction(loop_function_instance_name,false);
    end
    dependency_item=dependencies_list{cur_idx};
    %propagate any updated input args to the loop functions
    updateArgs(instance_name,dependency_item.FunctionArgs,'input');
    output_args=makeOutputStruct(function_struct);
    updateArgs(instance_name,output_args,'output');
    test_function_dependency_item=dependencies_list{test_function_dependecy_idx};
    test_output=test_function_handle(test_function_dependency_item.FunctionArgs);
end


for i=1:size(loop_functions,1)
    loop_function_instance_name=loop_functions{i}.InstanceName;
    clearArgs(loop_function_instance_name);
end


%end while
end
